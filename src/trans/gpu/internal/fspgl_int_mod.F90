! (C) Copyright 2000- ECMWF.
! (C) Copyright 2000- Meteo-France.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE FSPGL_INT_MOD
CONTAINS
SUBROUTINE FSPGL_INT(KF_UV,KF_SCALARS,KF_SCDERS,KF_OUT_LT,&
 &                   FSPGL_PROC,KFLDPTRUV,KFLDPTRSC)

USE PARKIND_ECTRANS ,ONLY : JPIM     ,JPRBT

USE TPM_DIM         ,ONLY : R,R_NDGNH, R_NDGL
USE TPM_TRANS       ,ONLY : FOUBUF_IN, LDIVGP, LVORGP
USE TPM_GEOMETRY    ,ONLY : G, G_NDGLU
USE TPM_DISTR       ,ONLY : D,D_NUMP,D_MYMS,D_NASM0,D_NPROCL,D_NSTAGT0B,D_NPNTGTB0,D_NPNTGTB1
USE TPM_FIELDS      ,ONLY : F
USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS
USE hip_profiling   ,ONLY : roctxRangePushA,&
                            roctxRangePop,&
                            roctxMarkA
USE iso_c_binding   ,ONLY : c_null_char
 
IMPLICIT NONE

INTEGER ret
!

INTEGER(KIND=JPIM) :: KM, KMLOC
INTEGER(KIND=JPIM), INTENT(IN) :: KF_UV,KF_SCALARS,KF_SCDERS,KF_OUT_LT
EXTERNAL  FSPGL_PROC
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)  :: KFLDPTRUV(:)
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)  :: KFLDPTRSC(:)

!
! ZFIELD 2nd dimension is extended from 0 to R%NDGL+1, while only 1 to R%NDGL
! is given from the north/south transforms, and only 1 to R%NDGL rows will be
! passed to the east/west transforms.
! the 2 extra rows are used inside the model Fourier space computations
! (outside the transform package - see FSPGLH in Arpege/IFS).
!
REAL(KIND=JPRBT) :: ZFIELD(2*KF_OUT_LT,0:R%NDGL+1)


INTEGER(KIND=JPIM) :: ISL, IGLS, JFLD, JGL ,IPROC,  IPROCS
INTEGER(KIND=JPIM) :: IPTRU,IST,J
INTEGER(KIND=JPIM) :: IDGNH,IDGL
INTEGER(KIND=JPIM) :: ISTAN(R%NDGNH),ISTAS(R%NDGNH)
INTEGER(KIND=JPIM) :: IFLDPTRUV(KF_UV),IFLDPTRSC(KF_SCALARS)
ret = roctxRangePushA("FSPGL_INT"//c_null_char)
!     ------------------------------------------------------------------
#ifdef ACCGPU
!$ACC DATA IF(PRESENT(KFLDPTRUV)) COPYIN(KFLDPTRUV,KFLDPTRSC)
!$ACC DATA CREATE(IFLDPTRUV,IFLDPTRSC,ISTAN,ISTAS,ZFIELD) &
!$ACC& PRESENT(D_MYMS,D_NSTAGT0B,D_NPNTGTB1,D_NPROCL,FOUBUF_IN,R_NDGL,R_NDGNH,G_NDGLU)
#endif
#ifdef OMPGPU
!WARNING: the last ALLOC statement should be PRESENT,ALLOC but cause issues with AMD compiler!
!$OMP TARGET DATA IF(PRESENT(KFLDPTRUV)) MAP(TO:KFLDPTRUV,KFLDPTRSC)
!$OMP TARGET DATA MAP(ALLOC:IFLDPTRUV,IFLDPTRSC,ISTAN,ISTAS,ZFIELD) &
!$OMP&            MAP(ALLOC:D_MYMS,D_NSTAGT0B,D_NPNTGTB1,D_NPROCL,FOUBUF_IN)
#endif
IF(PRESENT(KFLDPTRUV)) THEN
  IFLDPTRUV(:) = KFLDPTRUV(1:KF_UV)
  IFLDPTRSC(:) = KFLDPTRSC(1:KF_SCALARS)
ELSE
  DO J=1,KF_UV
    IFLDPTRUV(J) = J
  ENDDO
  DO J=1,KF_SCALARS
    IFLDPTRSC(J) = J
  ENDDO
ENDIF

!loop over wavenumber
DO KMLOC=1,D_NUMP
  KM = D_MYMS(KMLOC)
 
ISL = MAX(R_NDGNH-G_NDGLU(KM)+1,1)
IDGNH = R_NDGNH
IDGL = R_NDGL
#ifdef OMPGPU
!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO
#endif
#ifdef ACCGPU
!$ACC PARALLEL LOOP
#endif
DO JGL=ISL,IDGNH
  IPROC = D_NPROCL(JGL)
  ISTAN(JGL) = (D_NSTAGT0B(IPROC) + D_NPNTGTB1(KMLOC,JGL))*2*KF_OUT_LT
  IGLS = IDGL+1-JGL
  IPROCS = D_NPROCL(IGLS)
  ISTAS(JGL) = (D_NSTAGT0B(IPROCS) + D_NPNTGTB1(KMLOC,IGLS))*2*KF_OUT_LT
ENDDO

#ifdef OMPGPU
!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2)
#endif
#ifdef ACCGPU
!$ACC PARALLEL LOOP COLLAPSE(2)
#endif
DO JGL=ISL,IDGNH
  DO JFLD=1,2*KF_OUT_LT
    IGLS = IDGL+1-JGL
    ZFIELD(JFLD,JGL)  = FOUBUF_IN(ISTAN(JGL)+JFLD)
    ZFIELD(JFLD,IGLS) = FOUBUF_IN(ISTAS(JGL)+JFLD)
  ENDDO
ENDDO

IST = 1
IF(LVORGP) THEN
  IST = IST+2*KF_UV
ENDIF
IF(LDIVGP) THEN
  IST = IST+2*KF_UV
ENDIF
IPTRU = IST




CALL FSPGL_PROC(KM,ISL,IDGL,KF_OUT_LT,F%R1MU2,ZFIELD,&
 &   IPTRU,KF_UV,KF_SCALARS,&
 &   IFLDPTRUV)

#ifdef OMPGPU
!$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2)
#endif
#ifdef ACCGPU
!$ACC PARALLEL LOOP COLLAPSE(2)
#endif
 DO JGL=ISL,IDGNH
  DO JFLD=1,2*KF_OUT_LT
    IGLS = IDGL+1-JGL
    !OCL      NOVREC
    FOUBUF_IN(ISTAN(JGL)+JFLD) = ZFIELD(JFLD,JGL)
    FOUBUF_IN(ISTAS(JGL)+JFLD) = ZFIELD(JFLD,IGLS)
  ENDDO
ENDDO

!end loop over wavenumber
END DO

#ifdef OMPGPU
!$OMP END TARGET DATA
#endif
#ifdef ACCGPU
!$ACC END DATA
#endif
#ifdef OMPGPU
!$OMP END TARGET DATA
#endif
#ifdef ACCGPU
!$ACC END DATA
#endif
!     ------------------------------------------------------------------
CALL roctxRangePop()
CALL roctxMarkA("FSPGL_INT"//c_null_char)
END SUBROUTINE FSPGL_INT
END MODULE FSPGL_INT_MOD
