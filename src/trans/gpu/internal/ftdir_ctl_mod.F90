! (C) Copyright 2000- ECMWF.
! (C) Copyright 2000- Meteo-France.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE FTDIR_CTL_MOD
CONTAINS
SUBROUTINE FTDIR_CTL(KF_UV_G,KF_SCALARS_G,KF_GP,KF_FS, &
 &                   KVSETUV,KVSETSC,KPTRGP,&
 &                   KVSETSC3A,KVSETSC3B,KVSETSC2,&
 &                   PGP,PGPUV,PGP3A,PGP3B,PGP2)


!**** *FTDIR_CTL - Direct Fourier transform control

!     Purpose. Control routine for Grid-point to Fourier transform
!     --------

!**   Interface.
!     ----------
!     CALL FTDIR_CTL(..)

!     Explicit arguments :
!     --------------------
!     KF_UV_G      - global number of spectral u-v fields
!     KF_SCALARS_G - global number of scalar spectral fields
!     KF_GP        - total number of output gridpoint fields
!     KF_FS        - total number of fields in fourier space
!     PGP     -  gridpoint array
!     KVSETUV - "B" set in spectral/fourier space for
!                u and v variables
!     KVSETSC - "B" set in spectral/fourier space for
!                scalar variables
!     KPTRGP  -  pointer array to fields in gridpoint space

!     Method.
!     -------

!     Externals.  TRGTOL      - transposition routine
!     ----------  FOURIER_OUT - copy fourier data to Fourier buffer
!                 FTDIR       - fourier transform

!     Author.
!     -------
!        Mats Hamrud *ECMWF*

!     Modifications.
!     --------------
!        Original : 00-03-03

!     ------------------------------------------------------------------

USE PARKIND_ECTRANS ,ONLY : JPIM     ,JPRB,  JPRBT

USE TPM_GEN         ,ONLY : NOUT
!USE TPM_DIM
!USE TPM_GEOMETRY
USE TPM_TRANS       ,ONLY : ZGTF, FOUBUF_IN
USE TPM_DISTR       ,ONLY : D, MYPROC, NPROC

#ifdef USE_CUDA_AWARE_MPI_FT
USE TRGTOL_MOD      ,ONLY : TRGTOL_CUDAAWARE
#else
USE TRGTOL_MOD      ,ONLY : TRGTOL
#endif
USE FOURIER_OUT_MOD ,ONLY : FOURIER_OUT
USE FTDIR_MOD       ,ONLY : FTDIR
use ieee_arithmetic
USE hip_profiling   ,ONLY : roctxRangePushA,&
                            roctxRangePop,&
                            roctxMarkA
USE iso_c_binding   ,ONLY : c_null_char
!
IMPLICIT NONE


INTERFACE
  SUBROUTINE cudaProfilerStart() BIND(C,name='cudaProfilerStart')
    USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
    IMPLICIT NONE
  END SUBROUTINE cudaProfilerStart
END INTERFACE

INTERFACE
  SUBROUTINE cudaProfilerStop() BIND(C,name='cudaProfilerStop')
    USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT
    IMPLICIT NONE
  END SUBROUTINE cudaProfilerStop
END INTERFACE

! Dummy arguments

INTEGER :: ret
INTEGER(KIND=JPIM),INTENT(IN) :: KF_UV_G,KF_SCALARS_G,KF_GP,KF_FS
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPTRGP(:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
REAL(KIND=JPRB),OPTIONAL    , INTENT(IN) :: PGP(:,:,:)
REAL(KIND=JPRB),OPTIONAL    , INTENT(IN) :: PGPUV(:,:,:,:)
REAL(KIND=JPRB),OPTIONAL    , INTENT(IN) :: PGP3A(:,:,:,:)
REAL(KIND=JPRB),OPTIONAL    , INTENT(IN) :: PGP3B(:,:,:,:)
REAL(KIND=JPRB),OPTIONAL    , INTENT(IN) :: PGP2(:,:,:)

! Local variables
!REAL(KIND=JPRBT),ALLOCATABLE :: ZGTF(:,:)

INTEGER(KIND=JPIM) :: IST,JGL,IGL,JF_FS
INTEGER(KIND=JPIM) :: IVSETUV(KF_UV_G)
INTEGER(KIND=JPIM) :: IVSETSC(KF_SCALARS_G)
INTEGER(KIND=JPIM) :: IVSET(KF_GP)
INTEGER(KIND=JPIM) :: IFGP2,IFGP3A,IFGP3B,IOFF,J3
INTEGER(KIND=JPIM) :: IBEG,IEND,IINC
INTEGER(KIND=JPIM) :: ISIZE,IFIELDS,ICHUNK,ICHUNKS,JK

!     ------------------------------------------------------------------

! Field distribution in Spectral/Fourier space

!call cudaProfilerStart()
ret = roctxRangePushA("FTDIR_CTL"//c_null_char)

IF(PRESENT(KVSETUV)) THEN
  IVSETUV(:) = KVSETUV(:)
ELSE
  IVSETUV(:) = -1
ENDIF
IVSETSC(:) = -1
IF(PRESENT(KVSETSC)) THEN
  IVSETSC(:) = KVSETSC(:)
ELSE
  IOFF=0
  IF(PRESENT(KVSETSC2)) THEN
    IFGP2=UBOUND(KVSETSC2,1)
    IVSETSC(1:IFGP2)=KVSETSC2(:)
    IOFF=IOFF+IFGP2
  ENDIF
  IF(PRESENT(KVSETSC3A)) THEN
    IFGP3A=UBOUND(KVSETSC3A,1)
    DO J3=1,UBOUND(PGP3A,3)
      IVSETSC(IOFF+1:IOFF+IFGP3A)=KVSETSC3A(:)
      IOFF=IOFF+IFGP3A
    ENDDO
  ENDIF
  IF(PRESENT(KVSETSC3B)) THEN
    IFGP3B=UBOUND(KVSETSC3B,1)
    DO J3=1,UBOUND(PGP3B,3)
      IVSETSC(IOFF+1:IOFF+IFGP3B)=KVSETSC3B(:)
      IOFF=IOFF+IFGP3B
    ENDDO
  ENDIF
ENDIF

IST = 1
IF(KF_UV_G > 0) THEN
  IVSET(IST:IST+KF_UV_G-1) = IVSETUV(:)
  IST = IST+KF_UV_G
  IVSET(IST:IST+KF_UV_G-1) = IVSETUV(:)
  IST = IST+KF_UV_G
ENDIF
IF(KF_SCALARS_G > 0) THEN
  IVSET(IST:IST+KF_SCALARS_G-1) = IVSETSC(:)
  IST = IST+KF_SCALARS_G
ENDIF

! Transposition

CALL GSTATS(158,0)

CALL GSTATS(430,0)
#ifdef ACCGPU
!$ACC DATA IF(PRESENT(PGP))   COPYIN(PGP)
!$ACC DATA IF(PRESENT(PGPUV)) COPYIN(PGPUV)
!$ACC DATA IF(PRESENT(PGP2))  COPYIN(PGP2)
!$ACC DATA IF(PRESENT(PGP3A)) COPYIN(PGP3A)
!$ACC DATA IF(PRESENT(PGP3B)) COPYIN(PGP3B)
#endif
#ifdef OMPGPU
!$OMP TARGET DATA IF(PRESENT(PGP))   MAP(TO:PGP)
!$OMP TARGET DATA IF(PRESENT(PGPUV)) MAP(TO:PGPUV)
!$OMP TARGET DATA IF(PRESENT(PGP2))  MAP(TO:PGP2)
!$OMP TARGET DATA IF(PRESENT(PGP3A)) MAP(TO:PGP3A)
!$OMP TARGET DATA IF(PRESENT(PGP3B)) MAP(TO:PGP3B)
#endif
CALL GSTATS(430,1)

! needed ??? JF_FS=KF_FS-D%IADJUST_D
#ifdef USE_CUDA_AWARE_MPI_FT
CALL TRGTOL_CUDAAWARE(ZGTF,KF_FS,KF_GP,KF_SCALARS_G,IVSET,KPTRGP,&
 &PGP,PGPUV,PGP3A,PGP3B,PGP2)
#else
CALL TRGTOL(ZGTF,KF_FS,KF_GP,KF_SCALARS_G,IVSET,KPTRGP,&
 &PGP,PGPUV,PGP3A,PGP3B,PGP2)
#endif

#ifdef OMPGPU
!$OMP END TARGET DATA
!$OMP END TARGET DATA
!$OMP END TARGET DATA
!$OMP END TARGET DATA
!$OMP END TARGET DATA
#endif
#ifdef ACCGPU
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
!$ACC END DATA
#endif

CALL GSTATS(158,1)
CALL GSTATS(106,0)

! Fourier transform

IF(MYPROC > NPROC/2)THEN
  IBEG=1
  IEND=D%NDGL_FS
  IINC=1
ELSE
  IBEG=D%NDGL_FS
  IEND=1
  IINC=-1
ENDIF


CALL GSTATS(1640,0)
!!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) PRIVATE(JGL,IGL)
IF(KF_FS>0) THEN
  ! TRY THIS IN CHUNKS, ISIZE is even, need equal and even chunks too
  ISIZE=size(zgtf,1)
  !ICHUNKS=2
  !ICHUNK=ISIZE/ICHUNKS
  !ICHUNK=ICHUNK+MOD(ICHUNK,2)
  !DO JK=ICHUNKS,1,-1
    ! repeat some fields to have constant chunk size
    !IOFF=MAX(1,ISIZE-(ICHUNKS-JK+1)*ICHUNK+1)
    IOFF=1
    !ICHUNK=2*KF_FS+2
    ICHUNK=ISIZE
    CALL FTDIR(ICHUNK)
  !ENDDO
ENDIF

! Save Fourier data in FOUBUF_IN

  CALL FOURIER_OUT(KF_FS)
#ifndef USE_CUDA_AWARE_MPI_FT
#ifdef ACCGPU
  !$ACC UPDATE HOST(FOUBUF_IN)
#endif
#ifdef OMPGPU
  !$OMP TARGET UPDATE FROM(FOUBUF_IN)
#endif
#endif

CALL GSTATS(1640,1)
!DEALLOCATE(ZGTF)
CALL GSTATS(106,1)
!     ------------------------------------------------------------------
!call cudaProfilerStop()
call roctxRangePop()
call roctxMarkA("FTDIR_CTL"//c_null_char)
END SUBROUTINE FTDIR_CTL
END MODULE FTDIR_CTL_MOD

